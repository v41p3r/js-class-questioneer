[
    {
        "id": "a0f0ca9e-f92b-4994-8cd9-03c338311d4e",
        "question": "Какво е Front-end framework?",
        "answer": "Front-end framework е колекция от предварително написан JavaScript и CSS код, който се използва, за да помогне на разработчиците да изграждат уеб приложения по-ефективно",
        "example": ""
    },
    {
        "id": "2fc30e4c-41a9-4b2b-af84-b4a7755c6521",
        "question": "Какво е React компонент?",
        "answer": "Компонентът е самостоятелна част от код, която представлява специфична част от потребителски интерфейс, като бутон, формуляр или раздел от страница. Компонентите могат да бъдат вложени в други компоненти, позволявайки йерархична и модулна структура.",
        "example": "const MyComponent = () => {\n    return <h1>My Component</h1>;\n};"
    },
    {
        "id": "be89bd08-20a9-45ae-b0e8-fcf5298802f3",
        "question": "Какво е JSX?",
        "answer": "JSX е синтаксисно разширение за JavaScript, което позволява да се пишат подобни на HTML елементи във вашия JavaScript код. Улеснява създаването и манипулирането на елементите на потребителския интерфейс и е ключова характеристика на React. \nКомбинация от HMTL и JS. \nJSX е съкратено от JavaScript XML",
        "example": "const MyComponent = () => {\n  const hello = 'WORLD';\n  return <h1>{hello}</h1>;\n};"
    },
    {
        "id": "9935b65a-cab0-4069-b7ab-cad535eb1f19",
        "question": "Какво е Virtual DOM?",
        "answer": "React използва виртуален DOM, който е копие на действителния DOM и се съхранява в паметта. Когато състоянието на компонент се промени, React ще актуализира виртуалния DOM и след това ще определи най-ефективния начин за актуализиране на действителния DOM, минимизирайки броя на необходимите промени.",
        "example": ""
    },
    {
        "id": "c3f19a8f-4f59-4c6a-9c67-aa5445456419",
        "question": "Какво са Props & State?",
        "answer": "Props се използват за предаване на данни от родителски компонент към неговите деца, докато състоянието се използва за проследяване на данни, които могат да се променят в рамките на компонент. Както props, така и state позволяват на компонента да бъде динамичен и да актуализира своето поведение и изобразяване в отговор на промените",
        "example": ""
    },
    {
        "id": "c00ca8ff-9139-4f83-bb26-3980ecf4d998",
        "question": "Какво е Lifecycle?",
        "answer": "Компонентите на React имат поредица от методи, които се извикват в определени моменти от техния жизнен цикъл. Тези методи ви позволяват да извършвате действия в определени моменти, като например когато даден компонент е изобразен за първи път или когато неговият state или props са се променили.",
        "example": ""
    },
    {
        "id": "856a57a1-ab0a-401c-a464-14bf272a10c3",
        "question": "Какво е Unidirectional Data Flow?",
        "answer": "React следва еднопосочен поток от данни, което означава, че данните протичат в една посока през приложението, от родителските компоненти надолу към дъщерните компоненти. Това улеснява разсъжденията за състоянието на приложението и разбирането как промените в състоянието ще се отразят на потребителския интерфейс.",
        "example": ""
    },
    {
        "id": "ebfaaa49-0a73-4ffd-abbf-404af48b4f17",
        "question": "Какво е Vite?",
        "answer": "Инструмент за създаване на среда за разработване. Създава всички необходими файлове, скриптове, сървър и т.н. \nПредлага различни шаблони, по които може да се създаде приложение. \nСъздава минимално количество файлове, но всички необходими.",
        "example": "npm create vite@latest"
    },
    {
        "id": "e628c320-b18d-4bab-ad02-e7ec12285cdc",
        "question": "Какво е npm?",
        "answer": "Node Package Manager - предлага готови за използване JS модули. Инсталира се автоматично при нсталирането на Node.js. Позволява добавянето и премахването на модули към даден проект.",
        "example": ""
    },
    {
        "id": "159b4bac-e13c-4559-bba9-6f09b4ebf94d",
        "question": "Какво са node modules?",
        "answer": "Модулите, които в npm се наричат node modules (ноуд модули). При добавяне на модул към проект, той бива отбелязан във файл package.json и добавен в папка node_modules.",
        "example": ""
    },
    {
        "id": "6c15d2da-1c15-4a0f-8565-82ca99c1fbf4",
        "question": "Какво е предназначението на package.json?",
        "answer": "файл, съдържащ цялата информация за проект - име, скриптове, версия, зависимости и т.н.",
        "example": "{\n  \"name\": \"questioneer\",\n  \"private\": true,\n  \"version\": \"0.1.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"tsc && vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@emotion/react\": \"^11.10.6\",\n    \"@emotion/styled\": \"^11.10.6\",\n    \"@mui/icons-material\": \"^5.11.11\",\n    \"@mui/material\": \"^5.11.11\",\n    \"@uiw/react-textarea-code-editor\": \"^2.1.1\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"uuid\": \"^9.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^18.0.27\",\n    \"@types/react-dom\": \"^18.0.10\",\n    \"@types/uuid\": \"^9.0.1\",\n    \"@vitejs/plugin-react\": \"^3.1.0\",\n    \"typescript\": \"^4.9.3\",\n    \"vite\": \"^4.1.0\"\n  }\n}\n"
    },
    {
        "id": "851dd164-2f05-4552-9473-283154308f7f",
        "question": "Какво са Module bundlers?",
        "answer": "Служат за органзиране, събиране, компресиране на всички файлове на проекта. Резултата е структура готова за deploy.",
        "example": ""
    },
    {
        "id": "e696f7c5-da89-4dcc-ac8e-e5ae9502130e",
        "question": "Какво са клас компоненти?",
        "answer": "- Клас компонентите предлагат по-голяма функционалност.\n- Създават се чрез наследяването на React.Component класа.\n- Задължително трябва да се дефинира метода render() .\n- render() метода трябва да “връща” JSX, който да се визуализира.\n- Имат lifecycle методи.",
        "example": "class MyComponent extends React.Component {\n  render() {\n    return <h1>My Component</h1>;\n  }\n}"
    },
    {
        "id": "b295dce8-33be-4902-8181-306c5a4c6cea",
        "question": "Какво са функционални компоненти?",
        "answer": "- Представляват JS функции\n- Връщат JSX, който да се рендерира\n- Използват hooks за да достъпят lifecycle методите\n- В параметрите на функцията се дефинират props",
        "example": "const MyComponent = () => {\n  return <h1>My Component</h1>;\n};"
    },
    {
        "id": "a11fc60e-3435-4aa4-9b9f-37c50db615aa",
        "question": "Какво са Props & Children?",
        "answer": "- Съкратено от properties\n- Обект, съдържащ данните предавани от родителския компонент\n- Съдържа дъщерните компоненти (children)",
        "example": "const App = () => {\n  return (\n    <div>\n      <TextCard text='Hello, world!' />\n    </div>\n  );\n};\n\nconst TextCard = ({ text }) => {\n  return (\n    <h1>{text}</h1>\n  );\n};"
    },
    {
        "id": "dc3a2f70-48f5-494b-9d15-37ea16e70287",
        "question": "Какво е state?",
        "answer": "В React state е JavaScript обект, който съдържа информация за поведението на компонент или вътрешното му състояние.\nСъстоянието може да се променя чрез вътрешни методи на компонента и промените в state-a могат да задействат повторно изобразяване на компонента (rerender), за да се актуализира неговият потребителски интерфейс.",
        "example": ""
    },
    {
        "id": "43a0f0e5-09e3-45af-8d19-862eab28ac6e",
        "question": "Какво е hook?",
        "answer": "React hooks са функции, които позволяват да се използват състояние и други функции на React във функционални компоненти, вместо само в клас компоненти.",
        "example": ""
    },
    {
        "id": "b62961f5-00eb-4b01-a7ae-18f712d887c8",
        "question": "Какво е useState?",
        "answer": "- Използва се за създаване и контролиране на състояние (state) във функционален компонент\n- Приема като аргумент първоначалния стейт\n- Връща масив с два елемента - стейта и функция за манипулиране на стейта",
        "example": "import { useState } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  return (\n    <button onClick={() => setCount(count + 1)}>\n      Click {count} times\n    </button>\n  );\n};"
    },
    {
        "id": "9d360056-64b2-470d-81d7-881c8a9efc5c",
        "question": "Какво са Lifecycle & lifecycle methods?",
        "answer": "В React един компонент преминава през няколко етапа, наречени етапи на жизнения цикъл,. Тези етапи включват инициализация, монтиране (mount), актуализиране и демонтиране (unmount). Всеки етап има няколко метода, които се извикват в определени моменти, което позволява на разработчиците да извършват определени действия на всеки етап.",
        "example": "class MyComponent extends React.Component {\n\n  componentDidMount() {\n    console.log('Component did mount!');\n  }\n\n  componentWillUnmount() {\n    console.log('Component will unmount!');\n  }\n\n  render() {\n    return <h1>My Component</h1>;\n  }\n}"
    },
    {
        "id": "a0d54aff-f3e6-477f-82ba-f0688db8d2fe",
        "question": "Какво е useEffect?",
        "answer": "Позволява изпълнението на допълнителни ефекти в даден компонент, като извличане на данни или настройка на компонента. \nПриема callback функция която се извиква след изобразяване на компонента.\nПриема и масив от стойности, които се използват за определяне кога ефектът трябва да се стартира отново.\nПри празен масив се изпълнява при mount на компонента, а return функцията се извиква при unmount",
        "example": "import { useEffect } from \"react\";\n\nconst MyComponent = () => {\n  useEffect(() => {\n    console.log('Component did mount!');\n    return () => console.log('Component will unmount!');\n  }, []);\n  return <h1>My Component</h1>;\n};"
    },
    {
        "id": "42e85da2-87de-48e8-aec2-74c6761fa743",
        "question": "Какво е useMemo?",
        "answer": "- Приема функция „create“ и масив от зависимости. Връща запаметена стойност.\n- useMemo ще преизчисли запаметената стойност само когато една от зависимостите се е променила. Тази оптимизация помага да се избегнат скъпи изчисления при всяко рендиране.\n-  useMemo се използва за оптимизиране на приложенията\n- useMemo се използва за запаметяване на референции към обекти или  масиви. В случай, че резултата от функцията е примитивна стойност, не е небоходимо да се използва useMemo.",
        "example": "import { useState, useMemo } from \"react\";\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(0);\n  const [todos, setTodos] = useState([]);\n\n  // \"Тежката\" функция се извиква само\n  // при промяна на count, а не\n  // при всеки rerender на компонента\n  const calculation = useMemo(() => {\n    return expensiveCalculation(count);\n  }, [count]);\n\n  const increment = () => {\n    setCount((c) => c + 1);\n  };\n\n  const addTodo = () => {\n    setTodos((t) => [...t, \"New Todo\"]);\n  };\n\n  return (\n    <div>\n      <div>\n        <h2>My Todos</h2>\n        {todos.map((todo, index) => {\n          return <p key={index}>{todo}</p>;\n        })}\n        <button onClick={addTodo}>Add Todo</button>\n      </div>\n      <hr />\n      <div>\n        Count: {count}\n        <button onClick={increment}>+</button>\n        <h2>Expensive Calculation</h2>\n        {calculation}\n      </div>\n    </div>\n  );\n};\n\n// Примерна функция която прави сложни\n// изчисления отнемащи време\nconst expensiveCalculation = (num) => {\n  console.log(\"Calculating...\");\n  for (let i = 0; i < 1000000000; i++) {\n    num += 1;\n  }\n  return num;\n};"
    },
    {
        "id": "4bd785b0-c88b-42d2-9c69-afa1701e71c1",
        "question": "Какво е useRef?",
        "answer": "- useRef() връща променлив обект, чието свойство “current” е инициализирано към подаден аргумент initialValue). Върнатият обект ще се запази за целия живот на компонента.\n- Ref-овете се използват за достъпване на DOM елементи (не Virtual DOM).\n- Удобен е за запазване на променлива стойност между пререндериране.\n- useRef() не “уведомява” при промяна на стойността.",
        "example": "import { useRef } from \"react\";\n\nconst MyComponent = () => {\n  const inputRef = useRef();\n\n  const handleClick = () => {\n    console.log(inputRef.current.value);\n  };\n  return (\n    <div>\n      <textarea ref={inputRef} />\n      <button onClick={handleClick}>Print</button>\n    </div>\n  );\n};"
    },
    {
        "id": "28b14cfc-254f-4594-833c-aa53814f9e81",
        "question": "Какво са Synthetic events?",
        "answer": "- Синтетичните ивенти са wrapper-и около native browser event-ите, чиято цел е да унифицират ивентите при различните браузъри.\n- Синтетичните събития са различни от и не се свързват директно с native събитията на браузъра.",
        "example": ""
    },
    {
        "id": "e5cc1308-e706-4ab4-9535-3f32b39e67ae",
        "question": "Какво е раутинг?",
        "answer": "Раутинг се отнася до процеса на управление на изгледа в рамките на потребителски интерфейс (UI) на уеб приложение. Това включва свръзване на URL адреси към конкретни компоненти или страници в рамките на потребителския интерфейс и определяне промените в изгледа на приложението въз основа на потребителски взаимодействия. Целта на UI раутинга е да осигури безпроблемно и интуитивно изживяване за потребителя, което му позволява лесно да навигира до информацията или функционалността, от която се нуждае.",
        "example": ""
    },
    {
        "id": "47fca4de-46d1-44c9-bdc7-518a15c75204",
        "question": "Какво е React Router?",
        "answer": "React Router е популярна JavaScript библиотека за маршрутизиране в базирани на React уеб приложения. Той предоставя инфраструктура за маршрутизиране, която позволява на разработчиците да декларират маршрутите за своето приложение и да ги насочат към конкретни компоненти. С React Router разработчиците могат лесно да се справят с навигацията между страниците, да управляват URL адреса в адресната лента на браузъра и да запазят състоянието на приложението, докато потребителите навигират между страниците.",
        "example": ""
    },
    {
        "id": "7d9ee3f8-1704-401b-ac1f-fadac41e7db6",
        "question": "Какво е MaterialUI?",
        "answer": "MaterialUI е библиотека която предлага стилизирани компоненти базирани на Google's Material Design. Спомага за бързо изграждане на графичният дизайн на уеб приложения",
        "example": ""
    },
    {
        "id": "1134f6bb-1f65-4ad5-9231-88696ba44678",
        "question": "Какво е App state management?",
        "answer": "Управлението на състоянието на приложението се отнася до процеса на управление и организиране на състоянието или данните на приложение по начин, който позволява на приложението да функционира правилно и ефективно. С други думи, управлението на състоянието на приложението включва съхраняване и актуализиране на различните части от данни, от които едно приложение се нуждае, за да функционира, и гарантиране, че тези данни са достъпни за различните части на приложението, които се нуждаят от тях.",
        "example": ""
    },
    {
        "id": "0d977ad5-b920-4d21-9860-9e02aec1cc4d",
        "question": "Какво е Context?",
        "answer": "Позволява данните да бъдат предавани надолу по дървото на компонентите, без да се налага ръчно предаване на пропове на всяко ниво. Той предоставя начин за споделяне на данни между компоненти без необходимост от изрични пропове или междинни компоненти.",
        "example": ""
    },
    {
        "id": "7d729662-fc2f-4bf2-b9d9-2032b8700ac3",
        "question": "Какво е Unit Test?",
        "answer": "Unit testing е техника за тестване на софтуер, при която отделни единици или компоненти на софтуерно приложение се тестват изолирано от останалата част от системата, за да се провери дали всяка единица работи по предназначение. Единицата е най-малката тествана част от софтуерно приложение, като функция, метод или клас.",
        "example": ""
    },
    {
        "id": "096e7d94-403a-4e7f-9900-0d914c0be252",
        "question": "Какво е Test-Driven Development",
        "answer": "TDD е процес на разработка на софтуер, който включва писане на автоматизирани тестове за част от кода, преди действителният код да бъде написан.\nЦелта на TDD е да подобри качеството на кода, да намали дефектите и да увеличи производителността чрез улавяне на грешки в началото на процеса на разработка. Като първо пишат тестове, разработчиците са принудени да мислят за изискванията на кода и неговия дизайн, преди да напишат какъвто и да е код, което може да доведе до по-добре проектиран и по-поддържаем код. TDD често се свързва с гъвкави методологии за разработка на софтуер и се използва широко в съвременните практики за разработка на софтуер.",
        "example": ""
    },
    {
        "id": "11f5d18e-2205-49ae-a792-96ce817bd7bc",
        "question": "Какво е AAA методологията?",
        "answer": "Методологията AAA (Arrange-Act-Assert) е препоръчителен подход за структуриране на тестове. Методологията на AAA включва следните стъпки:\n1. Arrange: В тази стъпка разработчикът настройва необходимите тестови данни и създава всички обекти или зависимости, необходими за тестовия случай.\n2. Act: Разработчикът извършва действието, което трябва да бъде тествано, обикновено чрез извикване на функция или метод на обекта, който се тества.\n3. Assert: Разработчикът проверява дали резултатът от действието съответства на очакваните резултати, като използва твърдения или други техники за сравнение.",
        "example": "// Arrange\nconst numbers = [1, 2, 3];\nconst expected = 6;\n// Act\nconst actual = calculateTotal(numbers);\n// Assert\nassert.strictEqual(actual, expected);"
    }
]